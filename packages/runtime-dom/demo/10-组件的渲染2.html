<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>10-组件的渲染各种情形对比 part2</title>
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,monospace; }
    #controls { padding: 12px; border-bottom: 1px solid #e5e7eb; position: sticky; top: 0; background: #fff; z-index: 100;}
    #controls button { margin-right: 8px; padding: 6px 10px; border: 1px solid #d1d5db; background: #f9fafb; border-radius: 6px; cursor: pointer; }
    #controls button:focus { outline: 2px solid #2563eb; outline-offset: 2px; }
    main { padding: 12px; }
    .case { border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin-bottom: 14px; background: #fff; }
    .case h3 { margin: 0 0 6px; font-size: 14px; color: #111827; }
    .desc { color: #6b7280; font-size: 12px; margin-bottom: 8px; line-height: 1.4; }
    .actions { margin-bottom: 8px; }
    .actions button { margin-right: 6px; padding: 4px 8px; border: 1px solid #d1d5db; background: #f9fafb; border-radius: 6px; cursor: pointer; }
    .row { display: flex; gap: 10px; }
    .panel { flex: 1; border: 1px solid #e5e7eb; padding: 10px; min-height: 80px; background: #fafafa; position: relative; }
    .panel .label { position: absolute; top: 6px; left: 8px; font-size: 12px; font-weight: 600; color: #374151; }
    .panel .content { padding-top: 20px; }
  </style>
</head>
<body>
<div id="controls" role="region" aria-label="说明">
  <div style="font-weight:600; margin-bottom:6px;">10-组件的渲染各种情形对比 part2（左：官方 API，右：自定义 API）</div>
  <div style="color:#6b7280; font-size:12px;">渲染初始和渲染更新会自动切换API环境，但后续点击事件需手动切换环境。否则环境会错乱</div>
  <div>
    <button onclick="changeAPI('vue')">切换为官方api环境</button>
    <button onclick="changeAPI('custom')">切换为自定义api环境</button>
    <span id="env-text"></span>
  </div>
</div>

<main id="root"></main>

<script type="module">
  import {
    render as renderVue,
    h as hVue,
    Text as TextVue,
    Fragment as FragmentVue,
    ref as refVue,
    getCurrentInstance as getCurrentInstanceVue,
    onBeforeMount as onBeforeMountVue,
    onBeforeUpdate as onBeforeUpdateVue,
    onMounted as onMountedVue,
    onUpdated as onUpdatedVue
  } from "../../../node_modules/vue/dist/vue.runtime.esm-browser.js";
  import {
    render as renderCustom,
    h as hCustom,
    Text as TextCustom,
    Fragment as FragmentCustom,
    ref as refCustom,
    getCurrentInstance as getCurrentInstanceCustom,
    onBeforeMount as onBeforeMountCustom,
    onBeforeUpdate as onBeforeUpdateCustom,
    onMounted as onMountedCustom,
    onUpdated as onUpdatedCustom,
  } from '../dist/runtime-dom.esm.js'

  let render,h,Text,Fragment, ref,getCurrentInstance,
  onBeforeMount,
  onBeforeUpdate,
  onMounted,
  onUpdated
  function changeAPI(vueOrCustom) {
    if (vueOrCustom === 'vue') {
      render = renderVue;
      h = hVue
      Text = TextVue
      Fragment = FragmentVue
      ref = refVue
      getCurrentInstance = getCurrentInstanceVue
      onBeforeMount = onBeforeMountVue
      onBeforeUpdate = onBeforeUpdateVue
      onMounted = onMountedVue
      onUpdated = onUpdatedVue
    } else {
      render = renderCustom
      h = hCustom
      Text = TextCustom
      Fragment = FragmentCustom
      ref = refCustom
      getCurrentInstance = getCurrentInstanceCustom
      onBeforeMount = onBeforeMountCustom
      onBeforeUpdate = onBeforeUpdateCustom
      onMounted = onMountedCustom
      onUpdated = onUpdatedCustom
    }
    document.getElementById('env-text').innerHTML = '当前API：' + vueOrCustom
  }
  window.changeAPI = changeAPI

  const EmitComp = {
    setup(props, ctx) {
      const age = ref(18)
      ctx.expose({ a: 'abc' })
      return () => h(Fragment, null, [
        h('h3', '组件状态age.' + age.value),
        h('button', { onClick: () => age.value++ }, 'grow up'),
        h('button', { onClick: () => ctx.emit('my-event', age.value) }, '点这里触发事件'),
      ])
    }
  }

  // 父初始化 子初始化 父完成
  // 父更新 子更新 子完成 父完成
  const Child = {
    props: {
      value: String,
    },
    setup(props, { emit, expose, slots, attrs }) {
      console.log('child setup');
      console.log(getCurrentInstance(), 'child');
      // instance -> 钩子关联在一起，在特定的时机调用对应的钩子
      onBeforeMount(() => {
        console.log(getCurrentInstance(), 'child bug');
        console.log('child beforeMount');
      });
      onMounted(() => {
        console.log('child mounted');
      });
      onBeforeUpdate(() => {
        console.log('child onBeforeUpdate');
      });
      onUpdated(() => {
        console.log('child onUpdated');
      });
      return () => {
        return h('h3', '子: ' + props.value);
      };
    },
  };

  const Father = {
    setup(props, { emit, expose, slots, attrs }) {
      console.log('parent setup');
      console.log(getCurrentInstance(), 'parent');

      // instance -> 钩子关联在一起，在特定的时机调用对应的钩子
      onBeforeMount(() => {
        console.log('parent beforeMount');
      });
      onMounted(() => {
        console.log('parent mounted');
      });
      onBeforeUpdate(() => {
        console.log('parent onBeforeUpdate');
      });
      onUpdated(() => {
        console.log('parent onUpdated');
      });

      const age = ref(18);

      return () => {
        return h(Fragment, [
          h('h3', '组件状态age.' + age.value),
          h('button', { onClick: () => age.value++ }, 'grow up'),
          h(Child, { value: age.value + ''})
        ]);
      };
    },
  };

  const RefedComp = {
    setup(props, ctx) {
      const age = ref(18)
      ctx.expose({ age: () => age.value })
      return () => h(Fragment, null, [
        h('h3', '子组件状态age.' + age.value),
        h('button', { onClick: () => age.value++ }, 'grow up'),
      ])
    }
  }

  const RefComponent = {
    setup(props, { emit, expose, slots, attrs }) {
      const comp = ref(null);
      const el = ref(null);

      onMounted(() => {
        console.log('dom对象el: ', el.value);
        console.log('comp实例: ', comp.value, comp.value.age()); // comp.value即为子组件的引用，comp.value.a=100
      })
      return () => {
        return h('div', { ref: el, a: 100 }, h(RefedComp, { ref: comp})); // <div a="100"></div> ref指代dom元素的情况
      };
    },
  };

  function functionalComponent(props) {
    return h('h3', '函数式组件。接受的参数：' + props.a + props.b);
  }

  const cases = [
    {
      id: 'emit',
      title: '组件事件及卸载',
      desc: '点击【渲染更新】卸载组件. 事件触发的key有一个转换： \'click\' -> \'onClick\'',
      makeInit: () => h(EmitComp, { onMyEvent: (age) => alert('事件： 年龄是' + age) }),
      makeNext: () => h('ul','组件成功卸载'),
    },
    {
      id: 'lifeCycle',
      title: '组件生命周期',
      desc: '生命周期函数可以是异步的。挂载时，其所有同步子组件都已经被挂载之后才挂载父组件',
      makeInit: () => h(Father),
      makeNext: () => h('h1','-'),
    },
    {
      id: 'ref-comp',
      title: 'ref引用',
      desc: 'ref可以引用组件实例或者dom对象（3.5之后组件实例只能是expose的内容）',
      makeInit: () => h(RefComponent),
      makeNext: () => h('h1','-'),
    },
    {
      id: 'functional-component',
      title: '函数式组件',
      desc: '函数式组件是一种定义自身没有任何状态的组件的方式。它们很像纯函数：接收 props，返回 vnodes。函数式组件在渲染过程中不会创建组件实例 (也就是说，没有 this)，也不会触发常规的组件生命周期钩子。',
      makeInit: () => h(functionalComponent, { a: 1, b: 2 }),
      makeNext: () => h('h1','-'),
    },
  ]

  const $root = document.getElementById('root')

  function createCaseSection(c, index) {
    const section = document.createElement('section')
    section.className = 'case'
    section.setAttribute('data-id', c.id)

    const h3 = document.createElement('h3')
    h3.textContent = `${index + 1}. ${c.title}`

    const desc = document.createElement('div')
    desc.className = 'desc'
    desc.textContent = c.desc

    const actions = document.createElement('div')
    actions.className = 'actions'
    const btnInit = document.createElement('button')
    btnInit.type = 'button'
    btnInit.setAttribute('data-action', 'init')
    btnInit.textContent = '渲染初始'
    const btnUpdate = document.createElement('button')
    btnUpdate.type = 'button'
    btnUpdate.setAttribute('data-action', 'update')
    btnUpdate.textContent = '渲染更新'
    actions.appendChild(btnInit)
    actions.appendChild(btnUpdate)

    const row = document.createElement('div')
    row.className = 'row'

    const left = document.createElement('div')
    left.className = 'panel'
    const leftLabel = document.createElement('div')
    leftLabel.className = 'label'
    leftLabel.textContent = '官方'
    const leftContent = document.createElement('div')
    leftContent.className = 'content'
    leftContent.id = `app-${c.id}`
    left.appendChild(leftLabel)
    left.appendChild(leftContent)

    const right = document.createElement('div')
    right.className = 'panel'
    const rightLabel = document.createElement('div')
    rightLabel.className = 'label'
    rightLabel.textContent = '自定义'
    const rightContent = document.createElement('div')
    rightContent.className = 'content'
    rightContent.id = `custom-${c.id}`
    right.appendChild(rightLabel)
    right.appendChild(rightContent)

    row.appendChild(left)
    row.appendChild(right)

    section.appendChild(h3)
    section.appendChild(desc)
    section.appendChild(actions)
    section.appendChild(row)

    return section
  }

  function handleRender(which, c) {
    changeAPI('vue')
    const vnodeApp = (which === 'init' ? c.makeInit() : c.makeNext())
    render(vnodeApp, document.getElementById(`app-${c.id}`))

    changeAPI('custom')
    const vnodeCustom = (which === 'init' ? c.makeInit() : c.makeNext())
    render(vnodeCustom, document.getElementById(`custom-${c.id}`))
  }

  function mountAll() {
    cases.forEach((c, index) => {
      const section = createCaseSection(c, index)
      $root.appendChild(section)

      // 绑定按钮
      section.querySelector('[data-action="init"]').addEventListener('click', () => handleRender('init', c))
      section.querySelector('[data-action="update"]').addEventListener('click', () => handleRender('update', c))
    })

    // 默认全部渲染初始态
    cases.forEach(c => handleRender('init', c))
  }

  mountAll()
</script>
</body>
</html>
