<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>11-组件的渲染各种情形对比 part3</title>
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,monospace; }
    #controls { padding: 12px; border-bottom: 1px solid #e5e7eb; position: sticky; top: 0; background: #fff; z-index: 100;}
    #controls button { margin-right: 8px; padding: 6px 10px; border: 1px solid #d1d5db; background: #f9fafb; border-radius: 6px; cursor: pointer; }
    #controls button:focus { outline: 2px solid #2563eb; outline-offset: 2px; }
    main { padding: 12px; }
    .case { border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin-bottom: 14px; background: #fff; }
    .case h3 { margin: 0 0 6px; font-size: 14px; color: #111827; }
    .desc { color: #6b7280; font-size: 12px; margin-bottom: 8px; line-height: 1.4; }
    .actions { margin-bottom: 8px; }
    .actions button { margin-right: 6px; padding: 4px 8px; border: 1px solid #d1d5db; background: #f9fafb; border-radius: 6px; cursor: pointer; }
    .row { display: flex; gap: 10px; }
    .panel { flex: 1; border: 1px solid #e5e7eb; padding: 10px; min-height: 80px; background: #fafafa; position: relative; }
    .panel .label { position: absolute; top: 6px; left: 8px; font-size: 12px; font-weight: 600; color: #374151; }
    .panel .content { padding-top: 20px; }
  </style>
  <style lang="css">
    hr::after {
      background: #fff;
      content: "分割线";
      padding: 0 4px;
      position: relative;
      top: -13px;
    }
    hr {
      border: none;
      border-top: 3px double #333;
      color: #333;
      overflow: visible;
      text-align: center;
      height: 5px;
    }
  </style>
  <style>
    /* 全流程共6个类 enterfrom、active、to，leaveFrom、active、to */
    .x-enter-active,
    .x-leave-active {
      transition: opacity 0.8s ease;
    }

    .x-enter-from,
    .x-leave-to {
      opacity: 0;
    }
  </style>
</head>
<body>
<div id="controls" role="region" aria-label="说明">
  <div style="font-weight:600; margin-bottom:6px;">11-组件的渲染各种情形对比 part3（左：官方 API，右：自定义 API）</div>
  <div style="color:#6b7280; font-size:12px;">渲染初始和渲染更新会自动切换API环境，但后续点击事件需手动切换环境。否则环境会错乱</div>
  <div>
    <button onclick="changeAPI('vue')">切换为官方api环境</button>
    <button onclick="changeAPI('custom')">切换为自定义api环境</button>
    <span id="env-text"></span>
  </div>
</div>
vue: <div id="teleport-vue"></div>
custom: <div id="teleport-custom"></div>

<main id="root"></main>

<script type="module">
  import {
    render as renderVue,
    h as hVue,
    Text as TextVue,
    Fragment as FragmentVue,
    ref as refVue,
    getCurrentInstance as getCurrentInstanceVue,
    onBeforeMount as onBeforeMountVue,
    onBeforeUpdate as onBeforeUpdateVue,
    onMounted as onMountedVue,
    onUpdated as onUpdatedVue,
    provide as provideVue,
    inject as injectVue,
    Teleport as TeleportVue,
    Transition as TransitionVue,
    KeepAlive as KeepAliveVue,
  } from "../../../node_modules/vue/dist/vue.runtime.esm-browser.js";
  import {
    render as renderCustom,
    h as hCustom,
    Text as TextCustom,
    Fragment as FragmentCustom,
    ref as refCustom,
    getCurrentInstance as getCurrentInstanceCustom,
    onBeforeMount as onBeforeMountCustom,
    onBeforeUpdate as onBeforeUpdateCustom,
    onMounted as onMountedCustom,
    onUpdated as onUpdatedCustom,
    provide as provideCustom,
    inject as injectCustom,
    Teleport as TeleportCustom,
    Transition as TransitionCustom,
    KeepAlive as KeepAliveCustom,
  } from '../dist/runtime-dom.esm.js'

  let isVue = false
  let render,h,Text,Fragment, ref,getCurrentInstance,
    onBeforeMount, onBeforeUpdate, onMounted, onUpdated,provide,inject,Teleport,
  Transition,KeepAlive
  function changeAPI(vueOrCustom) {
    if (vueOrCustom === 'vue') {
      isVue = true
      render = renderVue;
      h = hVue
      Text = TextVue
      Fragment = FragmentVue
      ref = refVue
      getCurrentInstance = getCurrentInstanceVue
      onBeforeMount = onBeforeMountVue
      onBeforeUpdate = onBeforeUpdateVue
      onMounted = onMountedVue
      onUpdated = onUpdatedVue
      provide = provideVue
      inject = injectVue
      Teleport = TeleportVue
      Transition = TransitionVue
      KeepAlive = KeepAliveVue
    } else {
      isVue = false
      render = renderCustom
      h = hCustom
      Text = TextCustom
      Fragment = FragmentCustom
      ref = refCustom
      getCurrentInstance = getCurrentInstanceCustom
      onBeforeMount = onBeforeMountCustom
      onBeforeUpdate = onBeforeUpdateCustom
      onMounted = onMountedCustom
      onUpdated = onUpdatedCustom
      provide = provideCustom
      inject = injectCustom
      Teleport = TeleportCustom
      Transition = TransitionCustom
      KeepAlive = KeepAliveCustom
    }
    document.getElementById('env-text').innerHTML = '当前API：' + vueOrCustom
  }
  window.changeAPI = changeAPI

  const InjectComp = {
    setup(props, ctx) {
      const age = inject('age')
      const notProvide = inject('notProvide', '默认值')
      const growUp = inject('growUp')
      return () => h(Fragment, null, [
        h('h3', 'Inject组件的inject值age: ' + age.value),
        h('h3', 'Inject组件的inject值notProvide: ' + notProvide),
        h('button', { onClick: growUp }, 'grow up'),
      ])
    }
  }


  function MiddlefunctionalComponent(props) {
    return h(InjectComp);
  }

  const ProvideComp = {
    setup(props, ctx) {
      const age = ref(18)
      provide('age', age)
      provide('growUp', () => age.value++)
      return () => h(Fragment, null, [
        h('h3', 'Provide组件状态age: ' + age.value),
        h('button', { onClick: () => age.value++ }, 'grow up'),
        h('hr'),
        h(MiddlefunctionalComponent)
      ])
    }
  }

  const props = {
    name: 'x',
    onBeforeEnter(el) {
      console.log(isVue, 'onBeforeEnter');
    },
    onEnter(el) {
      console.log(isVue, 'onEnter');
    },
    onLeave(el) {
      console.log(isVue, 'onLeave');
    },
  };

  const KeeAliveComp = {
    props: {
      name: String,
    },
    setup(props, ctx) {
      const age = ref(18)
      return () => h(Fragment, null, [
        h('h3', props.name + '组件状态age: ' + age.value),
        h('button', { onClick: () => age.value++ }, 'grow up'),
      ])
    }
  }

  const KeepaliveOuter = {
    setup(props, ctx) {
      const flag = ref(true)
      return () => h(Fragment, null, [
        h(KeepAlive, null, {
            default: () => flag.value ? h(KeeAliveComp, {name: '天王', key: 'TW'} ): h(KeeAliveComp, {name: '地虎', key: 'DH'} )
        }),
        h('hr'),
        h('button', { onClick: () => flag.value = !flag.value }, '切换'),
      ])
    }
  }

  const cases = [
    {
      id: 'Provide-inject',
      title: '组件的provide/inject',
      desc: '建议尽可能将任何对响应式状态的变更都保持在供给方组件中。 有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数',
      makeInit: () => h(ProvideComp),
      makeNext: () => h('ul','组件成功卸载'),
    },
    {
      id: 'Teleport',
      title: 'Teleport',
      desc: '点击【渲染更新】查看更新效果。这里如果children不是数组会报错， 自己写的没考虑全面',
      makeInit: () => h(Teleport, { to: isVue ? '#teleport-vue' : '#teleport-custom' }, [h('span', 'teleport'), h('span', '-渲染到此处')]),
      makeNext: () => h(Teleport, { to: isVue ? '#teleport-vue' : '#teleport-custom' }, '如果不是数组会报错'),
    },
    {
      id: 'transition',
      title: 'Transition',
      desc: 'Transition组件。点击【渲染更新】查看动画',
      makeInit: () => h(Transition, props, {
        a: 1,
        default: () => {
          return h('div', {
            style: { width: '100px', height: '100px', background: 'red' },
          });
        },
      }),
      makeNext: () => h(Transition, props, {
        b: 2,
        default: () => {
          return h('p', {
            style: { width: '100px', height: '100px', background: 'blue' },
          });
        },
      })
    },
    {
      id: 'keepalive',
      title: 'KeeAlive',
      desc: 'KeepAlive组件缓存的是子组件的状态，子组件的状态是存在自己身上，如果自己或自己的父级被干掉了，那么它和它记录的缓存也就没了。',
      makeInit: () => h(KeepaliveOuter),
      makeNext: () => h('ul','组件成功卸载'),
    },
  ]

  const $root = document.getElementById('root')

  function createCaseSection(c, index) {
    const section = document.createElement('section')
    section.className = 'case'
    section.setAttribute('data-id', c.id)

    const h3 = document.createElement('h3')
    h3.textContent = `${index + 1}. ${c.title}`

    const desc = document.createElement('div')
    desc.className = 'desc'
    desc.textContent = c.desc

    const actions = document.createElement('div')
    actions.className = 'actions'
    const btnInit = document.createElement('button')
    btnInit.type = 'button'
    btnInit.setAttribute('data-action', 'init')
    btnInit.textContent = '渲染初始'
    const btnUpdate = document.createElement('button')
    btnUpdate.type = 'button'
    btnUpdate.setAttribute('data-action', 'update')
    btnUpdate.textContent = '渲染更新'
    actions.appendChild(btnInit)
    actions.appendChild(btnUpdate)

    const row = document.createElement('div')
    row.className = 'row'

    const left = document.createElement('div')
    left.className = 'panel'
    const leftLabel = document.createElement('div')
    leftLabel.className = 'label'
    leftLabel.textContent = '官方'
    const leftContent = document.createElement('div')
    leftContent.className = 'content'
    leftContent.id = `app-${c.id}`
    left.appendChild(leftLabel)
    left.appendChild(leftContent)

    const right = document.createElement('div')
    right.className = 'panel'
    const rightLabel = document.createElement('div')
    rightLabel.className = 'label'
    rightLabel.textContent = '自定义'
    const rightContent = document.createElement('div')
    rightContent.className = 'content'
    rightContent.id = `custom-${c.id}`
    right.appendChild(rightLabel)
    right.appendChild(rightContent)

    row.appendChild(left)
    row.appendChild(right)

    section.appendChild(h3)
    section.appendChild(desc)
    section.appendChild(actions)
    section.appendChild(row)

    return section
  }

  function handleRender(which, c) {
    changeAPI('vue')
    const vnodeApp = (which === 'init' ? c.makeInit() : c.makeNext())
    render(vnodeApp, document.getElementById(`app-${c.id}`))

    changeAPI('custom')
    const vnodeCustom = (which === 'init' ? c.makeInit() : c.makeNext())
    render(vnodeCustom, document.getElementById(`custom-${c.id}`))
  }

  function mountAll() {
    cases.forEach((c, index) => {
      const section = createCaseSection(c, index)
      $root.appendChild(section)

      // 绑定按钮
      section.querySelector('[data-action="init"]').addEventListener('click', () => handleRender('init', c))
      section.querySelector('[data-action="update"]').addEventListener('click', () => handleRender('update', c))
    })

    // 默认全部渲染初始态
    cases.forEach(c => handleRender('init', c))
  }

  mountAll()
</script>
</body>
</html>
