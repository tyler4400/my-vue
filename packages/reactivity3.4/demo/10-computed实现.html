<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>10-computed实现</title>
</head>
<body>
<h2>只读 computed（缓存验证）</h2>
<div>
  price: <span id="price"></span> | count: <span id="count"></span> | total: <span id="total"></span>
  <div>
    <button id="incPrice">price + 1</button>
    <button id="incCount">count + 1</button>
  </div>
  <small>打开控制台观察：只有依赖变更时 getter 才会重新计算</small>
  <hr/>
</div>

<h2>可写 computed（带 get/set）</h2>
<div>
  firstName: <span id="firstName"></span> | lastName: <span id="lastName"></span> | fullName: <span id="fullName"></span>
  <div>
    <input id="fullNameInput" placeholder="例如: Jack Rose"/>
    <button id="setFullName">设置 fullName</button>
  </div>
  <hr/>
</div>

<h2>依赖 reactive 对象的 computed</h2>
<div>
  a: <span id="a"></span> | b: <span id="b"></span> | sum: <span id="sum"></span>
  <div>
    <button id="incA">a + 1</button>
    <button id="incB">b + 1</button>
  </div>
</div>

<h2>验证 computed dirty（懒计算与缓存）</h2>
<div>
  n: <span id="n"></span> | double: <span id="double"></span> | getter 执行次数: <span id="getterRuns"></span> | 读取次数: <span id="readTimes"></span>
  <div>
    <button id="incN">n + 1（仅使 computed 脏）</button>
    <button id="readDouble">读取 double.value</button>
    <button id="readDoubleOnce">读取一次</button>
    <button id="readDouble5">读取5次</button>
    <button id="resetCounts">重置计数</button>
  </div>
  <small>先多次点击 n + 1，不会立即执行 computed；点击“读取”仅在首次读取时执行 getter，随后多次读取命中缓存不再执行。</small>
  <hr/>
  
</div>

<script type="module">
  import { reactive, ref, computed, effect } from '../dist/reactivity3.4.esm.js'
  // import { reactive, ref, computed, effect } from '../../reactivity-example/dist/reactivity-example.esm.js'
  // import { reactive, ref, computed, effect } from '../../../node_modules/vue/dist/vue.esm-browser.prod.js'

  // 1) 只读 computed：依赖 price、count，验证缓存与重新计算时机
  const price = ref(10)
  const count = ref(2)
  const total = computed(() => {
    console.log('[computed total] run')
    return price.value * count.value
  })
  effect(() => {
    document.getElementById('price').innerText = String(price.value)
    document.getElementById('count').innerText = String(count.value)
    document.getElementById('total').innerText = String(total.value)
  })
  document.getElementById('incPrice').addEventListener('click', () => price.value++)
  document.getElementById('incCount').addEventListener('click', () => count.value++)

  // 2) 可写 computed：通过 set 反向修改依赖的 ref
  const firstName = ref('Jack')
  const lastName = ref('Rose')
  const fullName = computed({
    get: () => `${firstName.value} ${lastName.value}`.trim(),
    set: (val) => {
      const [f = '', l = ''] = String(val).split(/\s+/)
      firstName.value = f
      lastName.value = l
    },
  })
  effect(() => {
    document.getElementById('firstName').innerText = firstName.value
    document.getElementById('lastName').innerText = lastName.value
    document.getElementById('fullName').innerText = fullName.value
  })
  document.getElementById('setFullName').addEventListener('click', () => {
    const input = document.getElementById('fullNameInput')
    fullName.value = input.value
  })

  // 3) 依赖 reactive 对象属性的 computed
  const state = reactive({ a: 1, b: 2 })
  const sum = computed(() => {
    console.log('[computed sum] run')
    return state.a + state.b
  })
  effect(() => {
    document.getElementById('a').innerText = String(state.a)
    document.getElementById('b').innerText = String(state.b)
    document.getElementById('sum').innerText = String(sum.value)
  })
  document.getElementById('incA').addEventListener('click', () => state.a++)
  document.getElementById('incB').addEventListener('click', () => state.b++)

  // 4) 验证 computed 的 dirty（懒计算与缓存）
  const n = ref(1)
  let getterRuns = 0
  let readTimes = 0
  const updateDirtyDemo = () => {
    document.getElementById('getterRuns').innerText = String(getterRuns)
    document.getElementById('readTimes').innerText = String(readTimes)
  }
  const double = computed(() => {
    getterRuns++
    console.log('[computed dirty demo] run')
    updateDirtyDemo()
    return n.value * 2
  })
  // 注意：此处 effect 仅订阅 n，用于展示“修改依赖不会立刻触发 computed 执行”
  effect(() => {
    document.getElementById('n').innerText = String(n.value)
  })
  document.getElementById('incN').addEventListener('click', () => n.value++)
  const readOnce = () => {
    readTimes++
    const val = double.value
    document.getElementById('double').innerText = String(val)
    updateDirtyDemo()
  }
  document.getElementById('readDouble').addEventListener('click', readOnce)
  document.getElementById('readDoubleOnce').addEventListener('click', readOnce)
  document.getElementById('readDouble5').addEventListener('click', () => {
    for (let i = 0; i < 5; i++) {
      readTimes++
      // 反复读取，若 n 未变更，仅首次会触发 getter
      void double.value
    }
    document.getElementById('double').innerText = String(double.value)
    updateDirtyDemo()
  })
  document.getElementById('resetCounts').addEventListener('click', () => {
    getterRuns = 0
    readTimes = 0
    updateDirtyDemo()
  })
  updateDirtyDemo()
</script>
</body>
</html>
