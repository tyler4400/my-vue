### 简答
- **receiver 是什么**：在 `Proxy` 的 `get/set` 拦截器中，`receiver` 表示“这次属性读/写的接收者”，也就是属性访问时应当作为 `this` 绑定的对象，以及写入时应当落盘到的对象。
- **典型取值**：
    - 直接访问 `proxy.foo`：`receiver === proxy`
    - 通过原型链访问（例如 `child` 的原型是 `proxy`，访问 `child.foo`）：`receiver === child`
    - 显式调用：`Reflect.get(target, key, someObj)` 时 `receiver === someObj`

```ts
const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    if (key === ReactiveFlags.IS_REACTIVE) return true

    console.log('get handler', target, key, receiver)
    return target[key]
  },
  set(target, key, value, receiver) {
    console.log('set handler', target, key, value, receiver)
    return true
  },
}
```

### 为什么重要
- **保证 getter/setter 中的 this 正确**：若属性是访问器（含 getter/setter），需要把 `receiver` 作为 `this` 传入；否则 `this` 可能被错误地绑定为 `target`。
- **原型链上的写入落点**：当对原型链上的属性赋值，按照规范应把值写到“接收者”（`receiver`），而不是写到 `target` 本身。
- **与 `super`/继承一致性**：`Reflect.get/set` 会用 `receiver` 模拟规范行为，确保类继承、`super` 里的属性访问语义正确。

### 正确的转发方式（关键点）
- 读：使用 `Reflect.get(target, key, receiver)`
- 写：使用 `Reflect.set(target, key, value, receiver)`

```ts
const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    if (key === ReactiveFlags.IS_REACTIVE) return true
    return Reflect.get(target, key, receiver)
  },
  set(target, key, value, receiver) {
    return Reflect.set(target, key, value, receiver)
  },
}
```

### 一个最小示例（直观理解差异）
```ts
const base = {
  msg: 'base',
  get value() {
    return this.msg
  }
}
const proxy = new Proxy(base, {
  get(target, key, receiver) {
    // A: 错误示范：this 绑定到 target（base）
    // return (target as any)[key]

    // B: 正确示范：this 绑定到 receiver（真实访问者）
    return Reflect.get(target, key, receiver)
  }
})

const child = Object.create(proxy)
child.msg = 'child'

console.log(child.value) // A: 'base'（错）  B: 'child'（对）
```

- 同理，`set` 也应使用 `Reflect.set(...)`，否则如 `child.x = 1` 可能会错误地写到 `base` 上。
